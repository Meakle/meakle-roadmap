# JS中循环里面的定时器

## 为什么如下代码会打印 6 个 6

```js
let i = 0
for(i = 0; i<6; i++){
  setTimeout(()=>{
    console.log(i)
  },0)
}
```

1. 因为`setTimeout`会等整个代码运行完了之后再运行（等主线程运行完了之后再运行），也就是当`for`循环执行完之后再执行。

2. 因为变量`i`是一个定义在全局的变量，因此定时器里面的`i`是共享着同一个作用域里面的同一个值。

3. 所以在执行完代码（主线程）之后，变量`i`的值已经成为了6，因此后面的所有`console.log()`操作都会成为`console.log(6)`；



换句话说，可以理解成这样的

```js
let i = 0
for(i = 0; i<6; i++){
    // 先循环五次
}

// 此时代码已经运行完了，然后我们再运行定时器
// 因为总共五次调用，所有我们后面有五次console.log(i)
// 而此时因为i的值已经计算完了，就是6。
// 可以这么理解，在js底层中可能不是这样的
setTimeout(()=>{
  console.log(i)
},0)

setTimeout(()=>{
  console.log(i)
},0)

setTimeout(()=>{
  console.log(i)
},0)

setTimeout(()=>{
  console.log(i)
},0)

setTimeout(()=>{
  console.log(i)
},0)
```



## 解决这个问题的方法

有两个常用的方法：

* 利用let
* 利用闭包



### 利用let

```js
for(let i = 0; i<6; i++){
  setTimeout(()=>{
    console.log(i)
  },0)
}
```

解析：`let`会给`for`的块作用域生成一个类似于闭包的效果，因此能够记住每一次的`i`的值，而这里的`let`还有一个效果，就是每一次的循环，在内存中实际上都会生成一个新的`i`，而新的`i`的值是上一次循环中`i`的值，因此能够实现每一次循环的`i`不一样，并且js能记住`i`

### 利用闭包

```js
let i;
for (i = 0; i < 6; i++) {
	!function (i){
        setTimeout(() => {
            console.log(i)
        }, 0)
    }()

}
```

解析：

1. 这里利用立即执行函数在每一次的循环中都执行一次这个函数，而这个函数的参数为`i`，记录着每一次循环中`i`的值。

2. 一个立即执行函数会生成一个块级作用域，这作用域里面有两个东西，一个是`i`的值，一个是匿名函数（箭头函数）。
3. 由于我们循环了五次，也就是说生成了五个块级作用域，且这五个块级作用域中的`i`都是不同的（原因见1）。

4. 我们知道，闭包会记住创建他的作用域的环境（因为作用域链），因此不同的匿名函数所获取的到的`i`都是不同的，因为他们处在不用的作用于中，父作用域也不相同。
5. 因此`console.log()`出的每个结果都是不同的。
6. 总结来说，因为他们都不是一个东西，所以结果不同。毕竟都不是一个块级作用域，相当于在内存中重新划分了空间





> 非常详细的博客，解答了我关于setTimeout的问题以及一些闭包的问题
>
> [链接](https://www.cnblogs.com/hahazexia/p/9446585.html)