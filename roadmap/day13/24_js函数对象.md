# JS函数对象

## 定义一个函数

### 具名函数

```js
function function_name (formal_parameters1, formal_parameters2){
    // 语句
    return 返回值;
}
```

### 匿名函数

当我们吧具名表达式的函数名去掉,这个就叫匿名函数

**函数表达式**

```js
let a = function(x, y){
    ....
}
// 创建了一个函数名为a的函数
```

所谓函数表达式是`function(x, y)`这一段。

第一行整行话的意思就是：利用函数表达式创建了匿名函数，然后将这个匿名函数的地址，按值传递给变量a



我们来讲述一个特殊的情况

```js
let a = function f(x, y){
    ...;
}
f();
// 此时这里将会报错，f()的作用域只在function f(x, y){}这里面
```



### 箭头函数

```js
let f1 = x => x*x;
let f2 = (x, y) => x*y;
let f3 = (x, y) => {
    return x*y;
}

f1(3);
f2(2, 3);
f3(3, 4);
```

上面还是有几个地方要说一下

* 对于前两行的区别来说，如果只有一个传入参数可以不加括号，如果有两个及以上的传入参数，那么就要有括号包起来
* 对于第二行与第三行的区别来说，如果函数体用了花括号包起来了，那么必须要`return`语句



我们再来讲一个特殊的情况

```js
let f1 = x => { name : x };

let f2 = x => ({name : x});
```

像第一行这种情况，js会将`name : x`当成`label`标签处理

解决方法就是在花括号外面加上小括号



### 构造函数

我们也可以使用构造函数的方法，但是我们一般不会使用

```js
let f = new Function('x', 'y', 'x + y');
```

基本不会用这种方式。



### 函数自身与函数调用的区别

函数自身：`fn`，也就是存储着函数的那一块内存地址

函数调用：`fn()`，也就是执行这个函数



## 函数的要素

### 调用时机

我们来看几个例子

```js
let i = 1;

function f1(){
    console.log(i);
}

f1();		// 1
i = 2;
f1();		// 2
```

这里`f1`函数所能打印出的值，和外部`i`的值是紧密联系的

```js
let i = 1;

function f1(){
    setTimeout(() => {
        console.log(i);
    }, 0)
}

f1();		// 2
i = 2;
```

这里出现这样的原因是因为`setTimeout`这个函数，他的出现会让他里面的东西进入任务队列，这个队列需要等主线程执行完毕之后才调用，当主线程执行完毕，也就是`i = 2`执行完毕，这个时候再执行`f1()`中`setTimeout`里面的`console.log(i)`。

因此这个时候的`i`就是2了



### 作用域

每一个函数都会默认创建一个作用域

作用域分为块级作用域和函数作用域



**作用域也能嵌套作用域**

```js
let i = 1;

for(let i = 0; i < 10; i++){
    let z = 'outter';
    for(let j = 1; j < 10; j++){
        let z = 'inner';
        console.log(z);
    }
   
}
```

这里就是两个作用域嵌套了，这里是两个块级作用域嵌套。

**如果嵌套的作用域里面有一个同名变量（这里是z）呢？**

按照就近原则，会沿着作用域链从自己开始往上寻找，找到最近的`z`

```js
function f1(){

    let a = 1;
    function f2() {
        let a = 2;
        function f3(){
            console.log(a);
        }

        a = 22;
        f3();       // 22
    }

    console.log(a); // 1
    a = 100;
    f2();           // 22 就是f3()的结果
}

f1();
// 1 22
```



### 闭包

上面的例子就包含了闭包的知识点。

首先闭包是一个函数，函数里面套函数，里面的那个函数就是闭包。

闭包的特点就是能够记住创建它的作用域。



### 形式参数

形参的作用域是位于函数内部的。

js中的`arguments`对象保存了函数的参数。

```js
function f(x){
 	
	console.log(arguments[0]);  // x的值
    console.log(arguments[1]);	// 如果你在传递实参的时候多了一个的话，没关系，他会存在arguments里面
    
    arguments[2] = '没想到吧，我还可以在函数体里面给实参';
    console.log(arguments[2]);
}

f(1, '我是外来者');
```

### 返回值

* 只有函数才有返回值
* 当返回返回一个值得时候，就代表这这个函数结束了
* 没有`return`的话一般情况默认返回`undefined`
* 只有函数才有返回值

### 调用栈

**什么是调用栈**

js引擎在调用函数前，需要把函数所在的环境push到一个栈里，当函数执行完之后，就会pop出函数，回到之前的环境里。



当你使用递归之后，有可能会挤爆调用栈。

### 函数提升

当你使用`function fn(){}` 来声明函数的时候，函数会自动提升到当前函数作用域的最上面

```js
for(;;){
    function f1(){
        console.log('1');
    }

    break;
}

f1();		// 1 块级作用域无法限制function
```

```js
function f1(){
    function f2(){
        console.log('1');
    }
}

f2();       // Uncaught ReferenceError: f2 is not defined
```

### arguments和this

箭头函数是没有这两个概念的。箭头函数中的this永远指向的是`window`对象



**如何传`arguments`**

`arguments`是一个伪数组

给函数传参就是给`arguments`赋值

你也可以在函数体里面给它赋值

上面有例子展示了

**如何传`this`**

`fn.call(xxx, 1, 2, 3)`

这里的xxx就是this，后面的是arguments

而且xxx会自动转换为对象



**两种调用方法的方式**

```js
person.sayHi();

person.sayHi.call(person);

// 两种方式是等价的。
```



















